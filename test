public Page<Ticket> findAllRelevantTickets(Pageable pageable, String customerId) {
    Predicate<?, ?> predicate = Predicates.or(
        // Condition 1 : Status is APPROVAL_PENDING or APPROVAL_REFUSED and approval.discussion = true
        Predicates.and(
            Predicates.in("status", "APPROVAL_PENDING", "APPROVAL_REFUSED"),
            Predicates.equal("approval.discussion", true)
        ),

        // Condition 2 : claimType.code in D and status in NEW, PROCESSING, etc.
        Predicates.and(
            Predicates.equal("claimType.code", "D"),
            Predicates.in("status", "NEW", "PROCESSING", "APPROVAL_PENDING", "APPROVAL_REFUSED")
        ),

        // Condition 3 : readCustomer is false and customer_id is X
        Predicates.and(
            Predicates.equal("readCustomer", false),
            Predicates.equal("customer.id", customerId)
        ),

        // Condition 4 : customer.eds = true and customer.id = X
        Predicates.and(
            Predicates.equal("customer.eds", true),
            Predicates.equal("customer.id", customerId)
        )
    );

    IMap<String, Ticket> map = hazelcastInstance.getMap("tickets");

    Collection<Ticket> allMatching = map.values(predicate);

    // Tri + pagination manuelle (Hazelcast ne supporte pas Pageable directement)
    List<Ticket> sorted = allMatching.stream()
        .sorted(Comparator.comparing(Ticket::getLastUpdateDate).reversed())
        .toList();

    int total = sorted.size();
    int start = (int) pageable.getOffset();
    int end = Math.min(start + pageable.getPageSize(), total);
    List<Ticket> paged = sorted.subList(start, end);

    return new PageImpl<>(paged, pageable, total);
}
