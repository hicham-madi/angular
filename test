private handleTicketResponse(response: MbotListV2): void {
  const receivedPage = response.tickets?.number ?? -1;
  const totalPagesFromResponse = response.tickets?.totalPages ?? -1;

  this.currentPage = receivedPage;

  const newTickets = response.tickets?.content ?? [];
  const totalElements = response.tickets?.totalElements ?? 0;

  if (receivedPage === 0) {
    this.tickets = newTickets;
  } else if (receivedPage < totalPagesFromResponse) {
    this.tickets = [...this.tickets, ...newTickets];
  }

  this.ticketsCount = totalElements;

  if (
    receivedPage + 1 >= totalPagesFromResponse ||
    newTickets.length === 0
  ) {
    this.scrollCompleted = true;
    this.tickets.push({ _spacer: true } as any);
  }

  this.isLoading = false;
}

fix(front): suppression de extractTicketsFromResponse et refactor du scroll infini pour utiliser une structure de réponse unifiée

public loadTicketsByCard(type: FilterCardType, page: number = 0): Observable<MbotListV2> {
  return this.mbotService.getTicketListByCard(type, page);
}

private handleTicketResponse(response: MbotListV2): void {
  const receivedPage = response.tickets?.number ?? -1;
  const totalPagesFromResponse = response.tickets?.totalPages ?? -1;

  this.currentPage = receivedPage;

  const newTickets = response.tickets?.content ?? [];
  const totalElements = response.tickets?.totalElements ?? 0;

  if (receivedPage === 0) {
    this.tickets = newTickets;
  } else if (receivedPage < totalPagesFromResponse) {
    this.tickets = [...this.tickets, ...newTickets];
  }

  this.ticketsCount = totalElements;

  if (
    receivedPage + 1 >= totalPagesFromResponse ||
    newTickets.length === 0
  ) {
    this.scrollCompleted = true;
    this.tickets.push({ _spacer: true } as any);
  }

  this.isLoading = false;
}
