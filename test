@Output() public loadMore = new EventEmitter<{ sortKey: string|null; isAsc: boolean|null }>();

public onCdkScroll(): void {
  const end = this.cdkVirtualScroll.getRenderedRange().end;
  const total = this.cdkVirtualScroll.getDataLength();
  const pageSize = 20;

  // seuil simple : on est “au bout” de la page visible
  const threshold = Math.ceil(total / pageSize) * pageSize;

  if (end >= threshold - 2) {
    // debug temporaire
    console.log('[table] loadMore emit', { end, total, threshold, hasPending: this.hasPendingPage });

    if (this.hasPendingPage) {
      this.loadMore.emit({
        sortKey: this.sort.direction ? this.sort.active : null,
        isAsc:   this.sort.direction ? this.sort.direction === 'asc' : null,
      });
    }
  }
}


protected onScroll(
  sort: { sortKey: string | null; isAsc: boolean | null },
  context: TicketContext
): void {
  if (this.isLoading || this.allPagesLoaded) return;

  const nextPage = this.currentPage + 1;
  this.isLoading = true;

  const complete = () => {
    this.isLoading = false;
    this.currentPage = nextPage;
  };

  const effective = (sort && sort.sortKey != null && sort.isAsc != null) ? sort : null;
  const opts = effective ? { sortKey: effective.sortKey, isAsc: effective.isAsc } : {};

  const card = this.activeCard ?? FilterCardType.NONE;

  // debug temporaire
  console.log('[page] onScroll ->', { nextPage, opts, hasPending: this.hasPendingPage });

  this.cardConfigFactory
    .loadTicketsByCard(card, context, nextPage, opts)
    .subscribe({
      next: (response) => { this.handleTicketResponse(response, context); complete(); },
      error: (err) => { console.error('Erreur lors du scroll :', err); complete(); },
    });
}
