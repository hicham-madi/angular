// au-dessus : imports‚Ä¶

export type SortState = { active: string | null; direction: 'asc' | 'desc' | null };

@Component({
  // ‚Ä¶
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class SolicitingsTableComponent {
  @Input() public tickets: Ticket[] = [];
  @Input() public displayedColumns: string[] = [];
  // ‚Ä¶
  @Input() public resetSortToken = 0;

  // üîÅ NOUVEAU : l‚Äô√©tat de tri vient du parent
  @Input() public sort!: SortState;

  @Output() public sortChanged = new EventEmitter<{ sortKey: string; isAsc: boolean }>();

  public ngOnChanges(changes: SimpleChanges): void {
    if (changes['resetSortToken'] && !changes['resetSortToken'].firstChange) {
      // on ne touche PAS au tri ici : on ne fait que remonter en haut de la liste
      this.cdkVirtualScroll?.scrollToIndex?.(0);
    }
  }

  protected getSortIcon(column: string): string {
    if (!this.sort || this.sort.active !== column || !this.sort.direction) return 'unfold_more';
    return this.sort.direction === 'asc' ? 'arrow_upward' : 'arrow_downward';
  }

  protected sortData(column: string): void {
    // On ne modifie pas this.sort ici, on demande au parent quoi faire
    if (!this.sort || this.sort.active !== column) {
      this.sortChanged.emit({ sortKey: column, isAsc: true });
      return;
    }
    if (this.sort.direction === 'asc') {
      this.sortChanged.emit({ sortKey: column, isAsc: false });
      return;
    }
    // 3e clic : retour tri par d√©faut
    this.sortChanged.emit({ sortKey: 'lastActivityTimestamp', isAsc: false });
  }
}

<!-- ic√¥ne li√©e par property binding (pas d'interpolation) -->
<mat-header-cell *matHeaderCellDef="let column" (click)="sortData(column)" [ngStyle]="columnConfig[column]?.style || {}">
  <ng-container *ngIf="column !== 'action'">
    <span class="column-label" [innerHTML]="columnConfig[column]?.label || column"></span>
    <mat-icon class="sort-icon" [fontIcon]="getSortIcon(column)"></mat-icon>
  </ng-container>
</mat-header-cell>

// m√™me type que dans l‚Äôenfant
type SortState = { active: string | null; direction: 'asc' | 'desc' | null };

export abstract class TicketsPageBase {
  // üîÅ NOUVEAU : l‚Äô√©tat de tri vit ici
  protected currentSort: SortState = { active: null, direction: null };

  protected onSortChanged(sort: { sortKey: string; isAsc: boolean }): void {
    // mettre √† jour l‚Äô√©tat (pilotera l‚Äôic√¥ne du child)
    this.currentSort = { active: sort.sortKey, direction: sort.isAsc ? 'asc' : 'desc' };

    this.currentPage = 0;
    this.scrollCompleted = false;
    this.allPagesLoaded = false;
    this.tickets = [];
    this.loadedElements = 0;
    this.hasPendingPage = true;

    const card = this.activeCard ?? FilterCardType.NONE;
    const opts = {
      sortKey: sort.sortKey,
      isAsc: sort.isAsc,
      searchTerm: this.searchTerm?.trim() ?? '',
      statusFilter: this.selectedStatus ?? '',
      agencyFilter: this.selectedAgency ?? '',
      collaboratorFilter: this.selectedCollaborator ?? '',
      campaignFilter: this.selectedCampaign ?? '',
      searchTypeFilter: this.selectedSearchType ?? '',
    };

    this.loadTicketsByCard(card, this.currentContext, 0, opts).subscribe({
      next: (response) => this.handleTicketResponse(response),
      error: (err) => console.error('Erreur tri page 0 :', err),
    });
  }

  /** Quand vous r√©initialisez (changement d‚Äôonglet, clic carte, reset filtres) */
  protected resetSort(): void {
    this.currentSort = { active: null, direction: null }; // ic√¥nes -> 'unfold_more'
    this.resetSortToken++;                                // pour remonter en haut si besoin
  }
}


<metabot-solicitings-table
  *ngIf="tickets.length > 0"
  [tickets]="tickets"
  [displayedColumns]="displayedColumns"
  [columnConfig]="columnConfig"
  [columnTemplates]="columnTemplates"
  [rowClick]="rowClickFn"
  [context]="this.currentContext"
  [selectedCard]="activeCard"
  [hasPendingPage]="hasPendingPage"
  [readCustomer]="readCustomerTable"
  [resetSortToken]="resetSortToken"
  [sort]="currentSort"                   <!-- üîÅ NOUVEAU -->
  (sortChanged)="onSortChanged($event)"
  (loadMore)="onScroll($event)"
></metabot-solicitings-table>
