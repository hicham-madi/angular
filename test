// âœ… nouveau helper
private resetInfiniteScrollState(): void {
  this.currentPage = 0;
  this.totalPages = 0;
  this.totalElements = 0;
  this.loadedElements = 0;
  this.hasPendingPage = true;   // on suppose quâ€™il reste des pages tant quâ€™on nâ€™a pas la 1Ê³áµ‰ rÃ©ponse
  this.allPagesLoaded = false;
  this.scrollCompleted = false;
}

// ... dans onCardClicked(...)
protected onCardClicked(type: FilterCardType, context: TicketContext): void {
  this.cardClickedOnce = true;

  // navigation (inchangÃ©) â€¦
  // â€¦

  // ðŸ”§ important : reset complet AVANT de (re)charger
  this.tickets = [];
  this.ticketsCountTeam = 0;
  this.resetInfiniteScrollState();

  if (this.activeCard === FilterCardType.NONE) {
    this.loadFullTicketList(context);
  } else {
    this.cardConfigFactory.loadTicketsByCard(type, context).subscribe({
      next: (response) => {
        this.handleTicketResponse(response, context);
        // (le reste inchangÃ©)
      },
      error: (err) => console.error('Erreur lors du chargement des tickets pour la carte sÃ©lectionnÃ©e :', err),
    });
  }
}

private handleTicketResponse(response: MbotListV2, context: TicketContext): void {
  const page  = response.tickets?.number ?? 0;
  const size  = response.tickets?.size   ?? 20;
  const content = response.tickets?.content ?? [];
  const totalElements = response.tickets?.totalElements ?? 0;

  this.totalPages = Math.ceil(totalElements / size);
  this.totalElements = totalElements;

  if (page === 0) {
    this.tickets = content;
  } else {
    const existingIds = new Set(this.tickets.map(t => t.id));
    const uniqueNew   = content.filter(t => !existingIds.has(t.id));
    this.tickets = [...this.tickets, ...uniqueNew];
  }

  this.loadedElements += content.length;
  this.hasPendingPage = this.loadedElements < this.totalElements;
  this.allPagesLoaded = !this.hasPendingPage;

  // â€¦
}
