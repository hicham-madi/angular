public MbotPageDto getTicketsByCard(MbotRequestDataDto mbotRequestData) {
    Customer customer = resolveCustomer();
    TicketFiltersDto filters = ticketBuilderService.buildTicketFilterFromMbotRequestData(customer, mbotRequestData);
    Pageable pageable = FiltersHelper.getPageable(filters);

    String crdType = Optional.ofNullable(mbotRequestData.getCardType()).orElse(FilterCardType.NONE.getCode());
    String ctx = IStringUtils.isEmpty(mbotRequestData.getContext()) ? "" : mbotRequestData.getContext();

    Optional<FilterCardType> optionalCardType = Arrays.stream(FilterCardType.values())
        .filter(c -> c.getCode().equals(crdType))
        .findFirst();

    Optional<TicketContext> optionalContext = Arrays.stream(TicketContext.values())
        .filter(c -> c.getName().equals(ctx))
        .findFirst();

    if (optionalCardType.isEmpty() || optionalContext.isEmpty()) {
        throw new IllegalArgumentException("CardType or Context inconnu : " + crdType + "/" + ctx);
    }

    FilterCardType cardType = optionalCardType.get();
    TicketContext context = optionalContext.get();

    Predicate<Object, Ticket> predicate = switch (context) {
        case SOLICITATIONS -> buildPredicateForSolicitations(filters, cardType);
        case TEAM -> buildPredicateForTeam(filters, cardType);
        // case NOUVEL_ONGLET -> buildPredicateForNewTab(filters, cardType);
    };

    List<Ticket> tickets = hazelcastRepository.findByPredicate(customer.getOrg(), predicate);
    long totalElements = tickets.size();

    int pageNumber = pageable.getPageNumber();
    int pageSize = pageable.getPageSize();
    int fromIndex = Math.min(pageNumber * pageSize, tickets.size());
    int toIndex = Math.min(fromIndex + pageSize, tickets.size());

    List<Ticket> pagedTickets = tickets.subList(fromIndex, toIndex);
    List<MbotTicketLightDto> ticketLightDto = IMapperTicket.INSTANCE.listTicketToListMbotTicketDto(pagedTickets);

    return MbotPageDto.builder()
        .tickets(new PageImpl<>(ticketLightDto, pageable, totalElements))
        .build();
}
private Predicate<Object, Ticket> buildPredicateForSolicitations(TicketFiltersDto filters, FilterCardType cardType) {
    Long customerId = filters.getCustomer().getId();
    String edsId = filters.getCustomer().getEdsId();

    return switch (cardType) {
        case READ_CUSTOMER -> TicketCriteria.readCustomer(customerId, edsId, false);
        case TREATMENT_IS_LATE_DS -> TicketCriteria.treatmentIsLateDs(customerId, edsId);
        case CUSTOMER_EDS_DS -> TicketCriteria.customerEdsDs(customerId, edsId);
        case REQUESTS -> TicketCriteria.requests(customerId);
        case REQUESTS_READ_CUSTOMER -> TicketCriteria.requestsReadCustomer(customerId, edsId);
        case CLAIMS -> TicketCriteria.claims(customerId, false);
        case CLAIMS_READ_CUSTOMER -> TicketCriteria.claimsReadCustomer(customerId, edsId, false);
        case APPROVALS -> TicketCriteria.approvals(customerId, false);
        case DISCUSSION_GROUPS -> TicketCriteria.discussionGroups(customerId, false);
        case DISCUSSION_GROUPS_READ_CUSTOMER -> TicketCriteria.discussionGroupsReadCustomer(customerId, edsId, false);
        case REQUESTS_EXPERT_SERVICE -> TicketCriteria.requestsExpertService(customerId, edsId, false);
        case REQUESTS_EXPERT_SERVICE_READ_CUSTOMER -> TicketCriteria.requestsExpertServiceReadCustomer(customerId, edsId, false);
        case REQUESTS_EXPERT_SERVICE_TREATMENT_IS_LATE -> TicketCriteria.requestsExpertServiceTreatmentIsLate(customerId, edsId, false);
        case REQUESTS_EXPERT_SERVICE_EDS -> TicketCriteria.requestsExpertServiceEds(customerId, edsId, false);
        default -> TicketCriteria.defaultPredicate(customerId, edsId, false); // si tu veux un fallback
    };
}
private Predicate<Object, Ticket> buildPredicateForTeam(TicketFiltersDto filters, FilterCardType cardType) {
    Long customerId = filters.getCustomer().getId();
    String edsId = filters.getCustomer().getEdsId();

    return switch (cardType) {
        case READ_CUSTOMER -> TicketCriteria.readCustomer(customerId, edsId, true);
        case TREATMENT_IS_LATE_DS -> TicketCriteria.treatmentIsLateDs(customerId, edsId);
        case CUSTOMER_EDS_DS -> TicketCriteria.customerEdsDs(customerId, edsId);
        case REQUESTS -> TicketCriteria.requests(customerId);
        case REQUESTS_READ_CUSTOMER -> TicketCriteria.requestsReadCustomer(customerId, edsId);
        case CLAIMS -> TicketCriteria.claims(customerId, true);
        case CLAIMS_READ_CUSTOMER -> TicketCriteria.claimsReadCustomer(customerId, edsId, true);
        case APPROVALS -> TicketCriteria.approvals(customerId, true);
        case DISCUSSION_GROUPS -> TicketCriteria.discussionGroups(customerId, true);
        case DISCUSSION_GROUPS_READ_CUSTOMER -> TicketCriteria.discussionGroupsReadCustomer(customerId, edsId, true);
        case REQUESTS_EXPERT_SERVICE -> TicketCriteria.requestsExpertService(customerId, edsId, true);
        case REQUESTS_EXPERT_SERVICE_READ_CUSTOMER -> TicketCriteria.requestsExpertServiceReadCustomer(customerId, edsId, true);
        case REQUESTS_EXPERT_SERVICE_TREATMENT_IS_LATE -> TicketCriteria.requestsExpertServiceTreatmentIsLate(customerId, edsId, true);
        case REQUESTS_EXPERT_SERVICE_EDS -> TicketCriteria.requestsExpertServiceEds(customerId, edsId, true);
        default -> TicketCriteria.defaultPredicate(customerId, edsId, true);
    };
}

