// tickets-page.base.ts

export abstract class TicketsPageBase {
  // ...
  public resetSortToken = 0;

  protected onCardClicked(type: FilterCardType): void {
    // ... ta logique existante (navigation, etc.)

    // reset pagination & comptages (si tu le fais déjà)
    this.resetPagination();

    // ❗ reset tri côté parent
    this.currentSort = { sortKey: null, isAsc: null };

    // ❗ trigger pour l’enfant
    this.resetSortToken++;

    // recharge
    this.loadTickets(this.activeCard);
  }

  protected applyFilters(): void {
    // si tu veux aussi reset le tri quand on applique des filtres, même principe:
    // this.currentSort = { sortKey: null, isAsc: null };
    // this.resetSortToken++;
    // ... puis reload
  }
}


<metabot-solicitings-table
  [tickets]="tickets"
  [displayedColumns]="displayedColumns"
  [columnConfig]="columnConfig"
  [context]="currentContext"
  [selectedCard]="activeCard"
  [resetSortToken]="resetSortToken"
  (sortChanged)="onSortChanged($event)"
  (loadMore)="onScroll()">
</metabot-solicitings-table>


// solicitings-table.component.ts
import { SimpleChanges } from '@angular/core';

export class SolicitingsTableComponent {
  @Input() resetSortToken = 0;

  protected sort = {
    active: null as string | null,
    direction: null as 'asc' | 'desc' | null,
  };

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['resetSortToken'] && !changes['resetSortToken'].firstChange) {
      // ❗ reset hard de l’état de tri => l’icône redevient 'unfold_more'
      this.sort.active = null;
      this.sort.direction = null;

      // (optionnel) remonter en haut de la liste virtuelle
      this.cdkvirtualscroll?.scrollToIndex?.(0);
      // Ne pas émettre sortChanged ici
    }
  }

  protected getSortIcon(column: string): string {
    if (!this.sort || this.sort.active !== column || !this.sort.direction) {
      return 'unfold_more';
    }
    return this.sort.direction === 'asc' ? 'arrow_upward' : 'arrow_downward';
  }
}
