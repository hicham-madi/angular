// TicketsPageBase.ts
protected applyFilters(): void {
  this.resetPagination();

  // 1) récupérer le tri courant, sinon fallback
  const hasValidSort =
    this.currentSort.sortKey != null && this.currentSort.isAsc != null;

  const sortKey = hasValidSort ? this.currentSort.sortKey! : 'lastActivityTimestamp';
  const isAsc   = hasValidSort ? this.currentSort.isAsc!   : false;

  // 2) construire les filtres
  const opts = {
    sortKey,
    isAsc,
    searchTerm:         this.searchTerm?.trim() ?? '',
    statusFilter:       this.selectedStatus ?? '',
    agencyFilter:       this.selectedAgency ?? '',
    collaboratorFilter: this.selectedCollaborator ?? '',
    campaignFilter:     this.selectedCampaign ?? '',
  };

  // 3) carte en cours (NONE autorisé)
  const card = this.activeCard ?? FilterCardType.NONE;

  // 4) passer par la factory => merge carte + filtres + tri
  this.cardConfigFactory
    .loadTicketsByCard(card, this.currentContext, 0, opts)
    .subscribe({
      next: (response) => {
        // si tu as déjà une méthode commune :
        this.handleTicketResponse(response);
        this.isLoading = false;
      },
      error: (err) => console.error("Erreur lors de l'application des filtres :", err),
    });
}

// AVANT
params.isAsc = false;
params.sortKey = 'lastActivityTimestamp';
// APRÈS
const hasValidSort = this.currentSort.sortKey != null && this.currentSort.isAsc != null;
params.sortKey = hasValidSort ? this.currentSort.sortKey! : 'lastActivityTimestamp';
params.isAsc   = hasValidSort ? this.currentSort.isAsc!   : false;
