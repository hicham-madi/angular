export class SolicitingsTableComponent {
  @ViewChild('virtualScroll', { static: true }) private readonly viewport!: CdkVirtualScrollViewport;

  @Input() public hasPendingPage = false;
  @Input() public loadingNextPage = false;
  @Input() public pageSize = 20;
  @Input() public tickets: Ticket[] = [];

  @Output() public loadMore = new EventEmitter<{ sortKey: string | null; isAsc: boolean | null }>();

  private scrollLocked = false;
  private readonly preloadOffset = 1;

  ngOnChanges(): void {
    // Si nouvelle page → on réarme
    if (this.tickets?.length && this.scrollLocked) {
      this.scrollLocked = false;
    }
  }

  public onCdkScroll(): void {
    if (!this.hasPendingPage) return;
    if (this.loadingNextPage) return;
    if (this.scrollLocked) return;

    const end = this.viewport.getRenderedRange().end;
    const total = this.viewport.getDataLength();
    const atBottom = end >= total - this.preloadOffset;

    if (atBottom) {
      this.scrollLocked = true; // On bloque IMMÉDIATEMENT
      this.loadMore.emit({
        sortKey: this.sort?.active ?? null,
        isAsc: this.sort?.direction === 'asc'
      });
    }
  }
}

appendAndFlags(newItems: Ticket[]) {
  this.tickets = [...this.tickets, ...(newItems ?? [])]; // ← déclenche bien un changement de référence
  this.hasPendingPage = (newItems?.length ?? 0) === this.pageSize;
}
