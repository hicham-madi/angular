protected applyFilters(context: TicketContext): void {
  this.scrollCompleted = false;
  this.isLoading = true;

  const params = this.listService.reinitParam(0); // reset page 0
  params.context = context;
  params.searchTerm = this.searchTerm?.trim() ?? '';
  params.statusFilter = this.selectedStatus ?? '';
  params.agencyFilter = this.selectedAgency ?? '';
  params.collaboratorFilter = this.selectedCollaborator ?? '';
  params.campaignFilter = this.selectedCampaign ?? '';
  if (TicketContext.TERMINATED === context) params.status = TicketStatus.CLOSED;

  // ðŸ”´ clÃ© du correctif : mÃ©moriser les filtres pour la pagination
  this.listService.setCurrentParams?.(params); // si la mÃ©thode n'existe pas, ajoute-la dans ListService

  this.mbotService.getTicketListV2(params).subscribe({
    next: (response) => {
      this.tickets = response.tickets.content ?? [];
      // flags de pagination
      this.totalElements = response.tickets.totalElements ?? this.tickets.length;
      this.loadedElements = this.tickets.length;
      this.hasPendingPage = this.loadedElements < this.totalElements;
      this.allPagesLoaded = !this.hasPendingPage;

      this.isLoading = false;

      // (ta logique existante pour statusTabs/TEAM/TERMINATED)
      // ...
      this.cdr.detectChanges();
    },
    error: (err) => { this.isLoading = false; console.error('Erreur filtres :', err); }
  });
}

protected onScroll(sort?: { sortKey: string|null; isAsc: boolean|null }, context: TicketContext): void {
  if (this.isLoading || this.allPagesLoaded) return;

  const nextPage = this.currentPage + 1;
  this.isLoading = true;
  const complete = () => { this.isLoading = false; this.currentPage = nextPage; };

  const opts = (sort?.sortKey != null && sort?.isAsc != null)
    ? { sortKey: sort.sortKey!, isAsc: sort.isAsc! }
    : {};

  const card = this.activeCard ?? FilterCardType.NONE;

  if (card === FilterCardType.NONE) {
    // ðŸ”´ on rÃ©utilise les mÃªmes filtres que ceux dâ€™applyFilters
    const base = this.listService.getCurrentParams();
    const params = { ...base, currentPages: nextPage, ...opts };

    this.mbotService.getTicketListV2(params).subscribe({
      next: (response) => { this.handleTicketResponse(response, context); complete(); },
      error: (err) => { console.error('Erreur scroll liste filtrÃ©e :', err); complete(); }
    });
  } else {
    this.cardConfigFactory
      .loadTicketsByCard(card, context, nextPage, opts)
      .subscribe({
        next: (response) => { this.handleTicketResponse(response, context); complete(); },
        error: (err)   => { console.error('Erreur scroll carte :', err); complete(); }
      });
  }
}

private currentParams!: TicketListParams;

reinitParam(page = 0): TicketListParams {
  this.currentParams = { ...DEFAULT_PARAMS, currentPages: page };
  return this.currentParams;
}

getCurrentParams(): TicketListParams { return this.currentParams; }
setCurrentParams(p: TicketListParams): void { this.currentParams = p; }

// dashboard-card-config.factory.ts
public loadTicketsByCard(
  type: FilterCardType,
  context: TicketContext,
  page: number = 0,
  opts?: { sortKey?: string | null; isAsc?: boolean | null }
): Observable<MbotListV2> {

  const params = { ...this.listService.getCurrentParams() };
  params.currentPages = page;
  params.context = context;

  // âœ… ajouter un filtre carte uniquement si une carte est choisie
  if (type !== FilterCardType.NONE) {
    if (TicketContext.TERMINATED === context) {
      params.status = TicketStatus.CLOSED;
      params.claimCodeFilter = FilterCardTypeMap.get(FilterCardType[type]);
    } else {
      params.cardType = FilterCardType[type];
    }
  }

  if (opts?.sortKey != null && opts?.isAsc != null) {
    params.sortKey = opts.sortKey;
    params.isAsc = opts.isAsc;
  }

  return this.mbotService.getTicketListV2(params);
}

// tickets-page.base.ts
protected onScroll(): void {
  if (this.isLoading || this.allPagesLoaded) return;

  const nextPage = this.currentPage + 1;
  this.isLoading = true;
  const complete = () => { this.isLoading = false; this.currentPage = nextPage; };

  const hasValidSort = this.currentSort.sortKey != null && this.currentSort.isAsc != null;
  const opts = hasValidSort ? { sortKey: this.currentSort.sortKey!, isAsc: this.currentSort.isAsc! } : {};

  const card = this.activeCard ?? FilterCardType.NONE;

  if (card === FilterCardType.NONE) {
    // âœ… pagination de la liste filtrÃ©e (sans carte), en rÃ©utilisant les params persistÃ©s
    const base = this.listService.getCurrentParams();
    const params = { ...base, currentPages: nextPage, ...(opts as any) };
    this.mbotService.getTicketListV2(params).subscribe({
      next: (response) => { this.handleTicketResponse(response, context); complete(); },
      error: (err) => { console.error('Erreur scroll (liste filtrÃ©e) :', err); complete(); }
    });
  } else {
    // pagination par carte
    this.cardConfigFactory.loadTicketsByCard(card, context, nextPage, opts).subscribe({
      next: (response) => { this.handleTicketResponse(response, context); complete(); },
      error: (err) => { console.error('Erreur scroll (carte) :', err); complete(); }
    });
  }
}
