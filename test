export class SolicitingsTableComponent {
  @Input() resetSortToken = 0;
  @Output() sortChanged = new EventEmitter<{ sortKey: string | null; isAsc: boolean | null }>();

  // État local du tri
  protected sort: { active: string | null; direction: 'asc' | 'desc' | null } = {
    active: null,
    direction: null,
  };

  ngOnChanges(changes: SimpleChanges): void {
    if ('resetSortToken' in changes && !changes['resetSortToken'].firstChange) {
      // ⚠️ réassignation, pas mutation
      this.sort = { active: null, direction: null };
      this.cdkVirtualScroll?.scrollToIndex(0);
      this.cdr?.markForCheck?.();
    }
  }

  protected sortData(column: string): void {
    if (this.sort.active !== column) {
      this.sort = { active: column, direction: 'asc' };
    } else {
      const next =
        this.sort.direction === 'asc' ? 'desc' :
        this.sort.direction === 'desc' ? null : 'asc';

      this.sort = { active: next ? column : null, direction: next };
    }

    // Émettre la valeur de tri
    if (!this.sort.direction) {
      this.sortChanged.emit({ sortKey: 'lastActivityTimestamp', isAsc: false });
    } else {
      this.sortChanged.emit({
        sortKey: this.sort.active!,
        isAsc: this.sort.direction === 'asc'
      });
    }

    this.cdr?.markForCheck?.();
  }

  protected getSortIcon(column: string): string {
    if (this.sort.active !== column || !this.sort.direction) return 'unfold_more';
    return this.sort.direction === 'asc' ? 'arrow_upward' : 'arrow_downward';
  }
}

protected onCardClicked(card: FilterCardType): void {
  // ... votre logique ...
  this.resetSortToken++;          // remet le tri du tableau à l’état neutre
}

protected onHeaderTabClick(): void {
  // ... votre logique ...
  this.resetSortToken++;          // idem
}

protected onFiltersChanged(e: FiltersPayload): void {
  // ... votre logique ...
  // this.resetSortToken++;       // ➜ mettez-le seulement si vous voulez perdre le tri après filtrage
}
