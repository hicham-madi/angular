protected onTabChange(tabValue: string): void {
  // üîÅ logique existante (calcul de la route cible) ‚Ä¶
  const isOngoing = tabValue === 'ongoing';
  const base = this.getBaseListSegment();
  const commands = isOngoing ? ['/', base] : ['/', base, 'terminated-list'];

  // üßπ IMPORTANT : on vide toute s√©lection de carte
  this.activeCard = FilterCardType.NONE;
  localStorage.removeItem('lastSelectedCard');

  // ‚ö†Ô∏è on enl√®ve le param√®tre ?card de l‚ÄôURL
  this.router.navigate(commands, {
    queryParams: { card: null },
    queryParamsHandling: 'merge', // on garde les autres params utiles, mais 'card' est supprim√©
  });

  // (optionnel mais utile) on r√©-initialise la pagination
  this.currentPage = 0;
  this.hasPendingPage = true;
}

resolve(route: ActivatedRouteSnapshot, _state: RouterStateSnapshot): Observable<TicketListPrefetch> {
  const context = route.data['context'] as TicketContext;

  let cardType: FilterCardType = FilterCardType.NONE;

  // ‚ùå En context TERMINATED / TERMINATED_TEAM on force NONE
  if (context !== TicketContext.TERMINATED && context !== TicketContext.TERMINATED_TEAM) {
    const qp = (route.queryParamMap.get('card') ?? '') as keyof typeof FilterCardType;
    const stored = localStorage.getItem('lastSelectedCard') as keyof typeof FilterCardType | null;

    if (qp && FilterCardType[qp] !== undefined) {
      cardType = FilterCardType[qp];
    } else if (stored && FilterCardType[stored] !== undefined) {
      cardType = FilterCardType[stored];
    }
  }

  // ‚Ä¶ reste du resolver
}

this.route.queryParamMap
  .pipe(/* ... */)
  .subscribe(qp => {
    const raw = (qp.get('card') ?? '') as keyof typeof FilterCardType;
    const next =
      raw && FilterCardType[raw] !== undefined ? FilterCardType[raw] : FilterCardType.NONE;

    this.activeCard = next;

    if (next === FilterCardType.NONE) {
      localStorage.removeItem('lastSelectedCard');
    }
  });
