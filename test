ilprivate readonly sortKeyMap: Record<string, string> = {
  id: 'ID',
  lastActivityTimestamp: 'LAST_ACTIVITY_TIMESTAMP',
  partLabel: 'PART_LABEL',
  domainLabel: 'DOMAIN_LABEL',
  objectLabel: 'OBJECT_LABEL',
  claimTypeLabel: 'CLAIM_TYPE_LABEL',
  slaLabel: 'SLA_LABEL',
  status: 'STATUS',
};

protected sortData(column: string): void {
  if (this.sort.active !== column) {
    this.sort.active = column;
    this.sort.direction = 'asc';
  } else {
    switch (this.sort.direction) {
      case 'asc':  this.sort.direction = 'desc'; break;
      case 'desc': this.sort.direction = null;   break;
      default:     this.sort.direction = 'asc';
    }
  }

  // reset listing & pagination avant d'appliquer le tri
  this.tickets = [];
  // si tu as currentPage/loadedElements ailleurs, remets-les à 0 ici aussi
  // this.currentPage = 0; this.loadedElements = 0; etc.

  // si le tri est nul, on appelle sans tri
  const sortBy = this.sort.direction ? (this.sortKeyMap[this.sort.active] ?? null) : null;
  this.fetchTickets(sortBy, this.sort.direction);
}

private fetchTickets(sortBy: string | null, sortDirection: 'asc' | 'desc' | null): void {
  const request: any = {
    page: 0,
    pageSize: 20,
    totalItems: this.tickets.length, // 0 après reset
    context: this.context,
    status: '',
    ...(sortBy && sortDirection ? { sortKey: sortBy, isAsc: sortDirection === 'asc' } : {}),
  };

  if (TicketContext.TERMINATED === this.context) {
    request.status = TicketStatus.CLOSED;
  }

  this.mbotService.getTicketListV2(request).subscribe((response) => {
    const newTickets = response.tickets?.content ?? [];
    this.tickets = newTickets; // pas d’append pour un tri initial
    this.detectChanges();
  });
}

import java.util.Locale;
import java.util.regex.Pattern;

public Comparator<Ticket> getComparator(String sortKey, boolean isAsc) {
    if (sortKey == null || sortKey.isBlank()) {
        return null;
    }

    // camelCase -> UPPER_SNAKE_CASE
    String key = sortKey
            .replaceAll("([a-z])([A-Z])", "$1_$2")
            .toUpperCase(Locale.ROOT);

    Comparator<Ticket> comparator = switch (key) {
        case "ID" -> Comparator.comparing(Ticket::getId);
        case "LAST_ACTIVITY_TIMESTAMP" -> Comparator.comparing(
                Ticket::getLastActivityTimestamp,
                Comparator.nullsLast(Comparator.naturalOrder())
        );
        case "PART_LABEL" -> Comparator.comparing(
                t -> t.getPart() != null && !StringUtils.isEmpty(t.getPart().getLabel())
                        ? t.getPart().getLabel() : null,
                Comparator.nullsLast(String::compareToIgnoreCase)
        );
        case "DOMAIN_LABEL" -> Comparator.comparing(
                t -> t.getDomain() != null ? t.getDomain().getLabel() : null,
                Comparator.nullsLast(String::compareToIgnoreCase)
        );
        case "OBJECT_LABEL" -> Comparator.comparing(
                t -> t.getObject() != null ? t.getObject().getLabel() : null,
                Comparator.nullsLast(String::compareToIgnoreCase)
        );
        case "CLAIM_TYPE_LABEL" -> Comparator.comparing(
                t -> t.getClaimType() != null ? t.getClaimType().getLabel() : null,
                Comparator.nullsLast(String::compareToIgnoreCase)
        );
        case "SLA_LABEL" -> Comparator.comparing(
                t -> t.getSla() != null ? t.getSla().getLabel() : null,
                Comparator.nullsLast(String::compareToIgnoreCase)
        );
        case "STATUS" -> Comparator.comparing(
                Ticket::getStatus,
                Comparator.nullsLast(String::compareToIgnoreCase)
        );
        default -> null;
    };

    return (comparator != null && !isAsc) ? comparator.reversed() : comparator;
}
