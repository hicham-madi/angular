@Output() public loadMore = new EventEmitter<{ sortKey: string | null; isAsc: boolean | null }>();
@Output() public sortChanged = new EventEmitter<{ sortKey: string; isAsc: boolean }>();

// ...

public onCdkScroll(): void {
  const { end } = this.cdkVirtualScroll!.getRenderedRange();
  const total = this.cdkVirtualScroll!.getDataLength();
  const pageSize = 20;
  const currentPageEnd = (Math.floor(total / pageSize) - (this.hasPendingPage ? 1 : 0)) * pageSize;

  if (end >= currentPageEnd + pageSize) {
    this.loadMore.emit({
      sortKey: this.sort.direction ? this.sort.active : null,
      isAsc: this.sort.direction ? this.sort.direction === 'asc' : null,
    });
  }
}

protected sortData(column: string): void {
  if (this.sort.active !== column) {
    this.sort.active = column;
    this.sort.direction = 'asc';
  } else {
    switch (this.sort.direction) {
      case 'asc':
        this.sort.direction = 'desc';
        break;
      case 'desc':
        this.sort.direction = null;
        this.sort.active = 'lastActivityTimestamp';
        // tri « défaut » desc côté back
        this.fetchTickets('lastActivityTimestamp', 'desc');
        // On notifie quand même le parent pour reset pagination
        this.sortChanged.emit({ sortKey: 'lastActivityTimestamp', isAsc: false });
        return;
      default:
        this.sort.direction = 'asc';
    }
  }

  // 1) recharge page 0 côté enfant (instantané visuel)
  this.fetchTickets(this.sort.active!, this.sort.direction);

  // 2) notifie le parent (pour qu’il garde le tri pendant le scroll)
  this.sortChanged.emit({
    sortKey: this.sort.active!,
    isAsc: this.sort.direction === 'asc',
  });
}

private fetchTickets(sortBy: string | null, sortDirection: 'asc' | 'desc' | null): void {
  const request = {
    page: 0,
    pageSize: 20,
    totalItems: this.tickets.length,
    context: this.context,
    status: '',
    ...(sortBy && sortDirection
      ? { sortKey: sortBy, isAsc: sortDirection === 'asc' }
      : {}),
  };

  if (TicketContext.TERMINATED === this.context) {
    request.status = TicketStatus.CLOSED;
  }

  this.mbotService.getTicketListV2(request).subscribe((response) => {
    const newTickets = response.tickets?.content ?? [];
    this.tickets = newTickets;
    this.detectChanges();
  });
}

<metabot-solicitings-table
  [tickets]="tickets"
  [displayedColumns]="displayedColumns"
  [columnConfig]="columnConfig"
  [columnTemplates]="columnTemplates"
  [rowClick]="rowClickFn"
  [context]="TicketContext.SOLICITATIONS"
  [selectedCard]="activeCard"
  [hasPendingPage]="hasPendingPage"
  (sortChanged)="onSortChanged($event)"
  (loadMore)="onScroll($event, TicketContext.SOLICITATIONS)">
</metabot-solicitings-table>

protected currentSort: { sortKey: string | null; isAsc: boolean | null } = {
  sortKey: null,
  isAsc: null,
};

protected onSortChanged(sort: { sortKey: string; isAsc: boolean }): void {
  // mémorise le tri
  this.currentSort = sort;

  // reset pagination & liste
  this.currentPage = 0;
  this.scrollCompleted = false;
  this.allPagesLoaded = false;
  this.tickets = [];
  this.loadedElements = 0;
  this.hasPendingPage = true;

  const card = this.activeCard ?? FilterCardType.NONE;
  const opts = { sortKey: sort.sortKey, isAsc: sort.isAsc };

  this.cardConfigFactory
    .loadTicketsByCard(card, this.context, 0, opts)
    .subscribe({
      next: (response) => this.handleTicketResponse(response, this.context),
      error: (err) => console.error('Erreur tri page 0 :', err),
    });
}

protected onScroll(
  sort: { sortKey: string | null; isAsc: boolean | null },
  context: TicketContext
): void {
  if (this.isLoading || this.allPagesLoaded) return;

  const nextPage = this.currentPage + 1;
  this.isLoading = true;

  const complete = () => {
    this.isLoading = false;
    this.currentPage = nextPage;
  };

  // utilise le sort reçu, sinon retombe sur le dernier tri connu
  const effective = (sort?.sortKey != null && sort?.isAsc != null)
    ? sort
    : (this.currentSort.sortKey != null && this.currentSort.isAsc != null)
      ? this.currentSort
      : null;

  const opts = effective
    ? { sortKey: effective.sortKey!, isAsc: effective.isAsc! }
    : {};

  const card = this.activeCard ?? FilterCardType.NONE;

  this.cardConfigFactory
    .loadTicketsByCard(card, context, nextPage, opts)
    .subscribe({
      next: (response) => {
        this.handleTicketResponse(response, context);
        complete();
      },
      error: (err) => {
        console.error('Erreur lors du scroll :', err);
        complete();
      },
    });
}
