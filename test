@Output() public scrolled = new EventEmitter<{ sortKey: string|null; isAsc: boolean|null }>();

public onCdkScroll(): void {
  // ... calcul du seuil
  if (end >= currentPageEnd + pageSize) {
    this.scrolled.emit({
      sortKey: this.sort.direction ? this.sort.active : null,
      isAsc:  this.sort.direction ? this.sort.direction === 'asc' : null,
    });
  }
}

<metabot-solicitings-table
  ...
  (scrolled)="onScroll(scrolled, TicketContext.SOLICITATIONS, $event)">
</metabot-solicitings-table>

protected onScroll(
  scrolled: EventEmitter<void>,
  context: TicketContext,
  sort?: { sortKey: string | null; isAsc: boolean | null }
): void {
  if (this.isLoading || this.allPagesLoaded) return;

  const nextPage = this.currentPage + 1;
  this.isLoading = true;

  const complete = () => {
    this.isLoading = false;
    this.currentPage = nextPage;
    scrolled.emit();
  };

  const opts =
    sort && sort.sortKey != null && sort.isAsc != null
      ? { sortKey: sort.sortKey, isAsc: sort.isAsc }
      : {};

  const type = this.activeCard ?? FilterCardType.NONE;

  const observable = this.cardConfigFactory.loadTicketsByCard(
    type,
    context,
    nextPage,
    opts                            // ⬅️ tri propagé
  );

  observable.subscribe({
    next: (response) => { this.handleTicketResponse(response, context); complete(); },
    error: (err) => { console.error('Erreur lors du scroll :', err); complete(); },
  });
}

loadTicketsByCard(
  type: FilterCardType,
  context: TicketContext,
  page = 0,
  opts?: { sortKey?: string | null; isAsc?: boolean | null }
) {
  const params: any = this.listService.reinitParam(page);
  params.context = context;
  if (context === TicketContext.TERMINATED) params.status = TicketStatus.CLOSED;

  if (opts?.sortKey != null && opts?.isAsc != null) {
    params.sortKey = opts.sortKey;
    params.isAsc   = opts.isAsc;
  }

  // ... autres filtres déjà présents
  return this.mbotService.getTicketListV2(params);
}
