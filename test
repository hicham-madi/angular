@Injectable({
  providedIn: 'root',
})
export class DashboardCardConfigFactory {
  constructor(
    private readonly listService: ListService,
    private readonly mbotService: MbotService
  ) {}

  public loadTicketsByCard(type: FilterCardType): Observable<MbotListV2> {
    const params = { ...this.listService.getCurrentParams() };

    // Envoyer le nom de l'enum en majuscules, comme attendu côté Java
    params.cardType = FilterCardType[type];

    return this.mbotService.getTicketsForCard(params).pipe(
      map((response) => {
        console.log('method ok', response);
        return response;
      }),
      catchError((err) => {
        console.error('Erreur lors du chargement des tickets pour la carte sélectionnée :', err);
        return of({ tickets: { content: [], totalElements: 0, totalPages: 0, number: 0 } } as MbotListV2);
      })
    );
  }

  public extractTicketsFromResponse(response: MbotListV2, card: FilterCardType): { tickets: Ticket[]; ticketsCount: number } {
    let tickets: Ticket[] = [];
    let ticketsCount = 0;

    switch (card) {
      case FilterCardType.APPROVALS:
        tickets = response.approvals?.content ?? [];
        ticketsCount = response.approvals?.totalElements ?? 0;
        break;

      case FilterCardType.CLAIMS:
        tickets = response.claims?.content ?? [];
        ticketsCount = response.claims?.totalElements ?? 0;
        break;

      case FilterCardType.DISCUSSION_GROUPS:
        tickets = response.discussionGroups?.content ?? [];
        ticketsCount = response.discussionGroups?.totalElements ?? 0;
        break;

      default:
        tickets = response.tickets?.content ?? [];
        ticketsCount = response.tickets?.totalElements ?? 0;
        break;
    }

    return { tickets, ticketsCount };
  }
}
protected onCardClicked(type: FilterCardType): void {
  if (this.activeCard === type) {
    // Si on clique sur la carte déjà active → désélectionner et recharger tous les tickets
    this.activeCard = FilterCardType.NONE;
    this.currentPage = 0;
    this.scrollCompleted = false;

    this.loadFullTicketList();
    return;
  }

  // Nouvelle sélection → charger les tickets filtrés
  this.activeCard = type;
  this.currentPage = 0;
  this.scrollCompleted = false;

  this.cardConfigFactory.loadTicketsByCard(type).subscribe({
    next: (response) => this.handleTicketResponse(response),
    error: (err) => console.error('Erreur lors du chargement des tickets pour la carte sélectionnée :', err),
  });
}

private loadFullTicketList(): void {
  this.cardConfigFactory.loadTicketsByCard(FilterCardType.NONE).subscribe({
    next: (response) => this.handleTicketResponse(response),
    error: (err) => console.error('Erreur lors du chargement de la liste complète des tickets :', err),
  });
}
