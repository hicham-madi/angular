public MbotPageDtoV2 getMyTickets(MbotRequestDataDtoV2 request) {
    // Récupère le client courant
    Customer customer = resolveCustomer();

    // Construit les filtres à partir de la requête entrante
    TicketFiltersDto filters = ticketBuilderService.buildTicketFilterFromMbotRequestData(customer, request);

    // Construit le Pageable (page, size)
    Pageable pageable = FiltersHelper.getPageable(filters);

    // Construit le prédicat déjà existant (selon ce que tu as déjà)
    Predicate<Object, Ticket> predicate = TicketCriteria.fromFilters(filters);

    // Appelle la méthode Hazelcast paginée
    Page<Ticket> page = hazelcastRepository.findMatchingTickets(
        customer.getOrg(),
        filters.getCustomer().getId(),
        filters.getCustomer().getEdsId(),
        predicate,
        pageable
    );

    // Convertit en DTO
    List<MbotTicketLightDto> ticketLightDto = IMapperTicket.INSTANCE.listTicketToListMbotTicketDto(page.getContent());

    // Calcule les stats uniquement sur les éléments récupérés
    TicketCardsDto stats = ticketStatsService.computeStats(page.getContent(), customer.getId(), customer.getEdsId());

    // Liste des statuts uniques dans la page
    Set<String> statusList = page.getContent().stream()
        .map(Ticket::getStatus)
        .filter(Objects::nonNull)
        .collect(Collectors.toSet());

    return MbotPageDtoV2.builder()
        .tickets(new PageImpl<>(ticketLightDto, pageable, page.getTotalElements()))
        .stats(stats)
        .statusList(statusList)
        .build();
}
