this.mbotService.getTicketListV2(params).subscribe({
  next: (response) => {
    const newItems = response?.tickets?.content ?? [];

    // 1) append + calcul de hasPendingPage (basÃ© sur la page reÃ§ue)
    appendAndFlags(newItems, response);

    // 2) mettre Ã  jour les compteurs/onglets, SANS toucher tickets/hasPendingPage
    this.updateCountersOnly(response, context);

    complete();
  },
  error: (err) => { console.error('Erreur scroll liste filtrÃ©e :', err); complete(); }
});

const appendAndFlags = (newItems: Ticket[], response: any) => {
  // IMPORTANT: changer la rÃ©fÃ©rence pour dÃ©clencher ngOnChanges cÃ´tÃ© enfant
  this.tickets = [...this.tickets, ...(newItems ?? [])];

  // â€”â€”â€” Calcul fiable de â€œreste-t-il une page ?â€ â€”â€”â€”
  // 1) Si lâ€™API renvoie un indicateur de derniÃ¨re page :
  if (response?.tickets?.last !== undefined) {
    this.hasPendingPage = !response.tickets.last;
  } else if (response?.tickets?.number !== undefined && response?.tickets?.totalPages !== undefined) {
    // 2) Si elle renvoie page courante + nb de pages :
    this.hasPendingPage = (response.tickets.number + 1) < response.tickets.totalPages;
  } else {
    // 3) Fallback: taille de page
    this.hasPendingPage = (newItems?.length ?? 0) === this.pageSize;
  }
};

private updateCountersOnly(response: any, context: TicketContext): void {
  try {
    const size = response?.tickets?.size ?? 20;
    const totalElements = response?.tickets?.totalElements ?? 0;
    this.totalPages = Math.ceil(totalElements / size);
    this.totalElements = totalElements;

    switch (context) {
      case TicketContext.SOLICITATIONS: {
        this.tableConfigFactory.ticketsCountSolicitations = totalElements;
        this.ticketsCountSolicitations = totalElements;
        break;
      }
      case TicketContext.TEAM: {
        this.ticketsCountTeam = totalElements;
        break;
      }
    }

    // âš ï¸ Ne touche PAS Ã  this.tickets, ni hasPendingPage ici
    // âš ï¸ Ne fais pas de â€œloadedElements += content.lengthâ€ ici
  } catch (e) {
    console.error('Erreur dans updateCountersOnly :', e);
  }
}

if (page === 0) {
  // initial load uniquement
  this.tickets = content;
} // sinon ne touche pas aux tickets ici

this.loadedElements += content.length;
this.hasPendingPage = this.loadedElements < this.totalElements;

if (atBottom) {
  this.scrollLocked = true;             // ğŸ”’ blocage immÃ©diat
  this.loadMore.emit(...);
}
public ngOnChanges() {
  if (len !== this.lastDataLength) {
    this.lastDataLength = len;
    this.scrollLocked = false;          // âœ… rÃ©armement Ã  lâ€™append
  }
}
