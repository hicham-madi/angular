@RestController
@RequestMapping("/api/tickets")
public class TicketController {

    private final TicketService ticketService;

    public TicketController(TicketService ticketService) {
        this.ticketService = ticketService;
    }

    @GetMapping("/by-card")
    public ResponseEntity<Page<Ticket>> getTicketsByCard(
            @RequestParam("userId") String userId,
            @RequestParam("cardType") CardTypeConfig cardType,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        // 1) Charger tous les tickets de Hazelcast
        List<Ticket> allTickets = ticketService.getTicketsFromCache(userId);

        // 2) Filtrer localement en fonction du cardTypeConfig
        List<Ticket> filtered = allTickets.stream()
                .filter(ticket -> ticketMatchesCardTypeConfig(ticket, cardType, userId))
                .collect(Collectors.toList());

        // 3) Appliquer la pagination sur la liste filtrée
        Page<Ticket> paged = paginate(filtered, page, size);

        return ResponseEntity.ok(paged);
    }
}
private <T> Page<T> paginate(List<T> items, int page, int size) {
    int start = page * size;
    int end = Math.min(start + size, items.size());

    List<T> content = start > items.size() ? Collections.emptyList() : items.subList(start, end);

    return new PageImpl<>(content, PageRequest.of(page, size), items.size());
}
public List<Ticket> getTicketsFromCache(String userId) {
    // Exemple avec Hazelcast, suppose une map "tickets" contenant les tickets
    IMap<String, Ticket> ticketMap = hazelcastInstance.getMap("tickets");

    // Charge tous les tickets dont le customer_id correspond à l'utilisateur
    return ticketMap.values(Predicates.equal("customer_id", userId))
                    .stream()
                    .collect(Collectors.toList());
}
