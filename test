protected initialization(context: TicketContext): void {
  this.currentContext = context;

  this.metabotBridge.setEventHandler(e => {
    if (this.constantsService.isOnSocketReceive(e)) this.loadTickets(this.activeCard);
  });

  // 1) snapshot → valeur de départ (celle déjà préchargée par le resolver)
  const k = (this.route.snapshot.queryParamMap.get('card') ?? '') as keyof typeof FilterCardType;
  const initialCard =
    k && FilterCardType[k] !== undefined ? FilterCardType[k] : FilterCardType.NONE;

  // 2) écouter les changements réels d’URL (après init)
  this.route.queryParamMap.pipe(
    map(qp => (qp.get('card') ?? '') as keyof typeof FilterCardType),
    map(key => (key && FilterCardType[key] !== undefined ? FilterCardType[key] : FilterCardType.NONE)),
    distinctUntilChanged(),
    filter(card => card !== initialCard) // évite la 1re émission
  ).subscribe(card => {
    this.onCardClicked(card);            // déclenche le fetch selon la carte

    // persistance
    if (card !== FilterCardType.NONE) localStorage.setItem('lastSelectedCard', card.toString());
    else localStorage.removeItem('lastSelectedCard');
  });
}
