// solicitings-table.component.ts
import { SimpleChanges } from '@angular/core';

@Input() public hasPendingPage = false;
@Input() public loadingNextPage = false;

private scrollLocked = false;
private lastLength = 0;
private prevLoading = false;

public ngOnChanges(changes: SimpleChanges): void {
  // 1) R√©armement quand la longueur change (append r√©el)
  const len = this.tickets?.length ?? 0;
  if (len !== this.lastLength) {
    this.lastLength = len;
    this.scrollLocked = false;
  }

  // 2) R√©armement quand un chargement se termine, m√™me si rien n'a √©t√© ajout√©
  if (changes['loadingNextPage']) {
    const prev = this.prevLoading;
    this.prevLoading = this.loadingNextPage;
    if (prev && !this.loadingNextPage && this.hasPendingPage) {
      this.scrollLocked = false;
    }
  }
}

public onCdkScroll(): void {
  if (!this.hasPendingPage) return;
  if (this.loadingNextPage) return;
  if (this.scrollLocked) return;

  const end = this.viewport.getRenderedRange().end;
  const total = this.viewport.getDataLength();

  if (end < Math.max(0, total - 1)) return; // pas encore tout en bas

  this.scrollLocked = true; // üîí anti-rafale

  this.loadMore.emit({
    sortKey: this.sort?.active ?? null,
    isAsc: this.sort?.direction === 'asc' ? true
         : this.sort?.direction === 'desc' ? false
         : null,
  });
}

<metabot-solicitings-table
  [tickets]="tickets"
  [hasPendingPage]="hasPendingPage"
  [loadingNextPage]="isLoading"   <!-- indispensable -->
  (loadMore)="onScroll(TicketContext.SOLICITATIONS)">
</metabot-solicitings-table>

if (this.isLoading) return;
if (!this.hasPendingPage) return;

this.isLoading = true;
const nextPage = this.currentPage + 1;
const complete = () => { this.isLoading = false; this.currentPage = nextPage; };


const page = response.tickets?.number ?? 0;
const size = response.tickets?.size ?? 20;
const content = response.tickets?.content ?? [];

if (page === 0) {
  this.tickets = content;
  this.loadedElements = content.length;
} else {
  const existingIds = new Set(this.tickets.map(t => t.id));
  const uniqueNewTickets = content.filter(t => !existingIds.has(t.id));
  this.loadedElements += uniqueNewTickets.length;   // ‚úÖ compter ce qui est vraiment ajout√©
  this.tickets = [...this.tickets, ...uniqueNewTickets]; // ‚úÖ nouvelle r√©f√©rence
}

// hasPendingPage calcul√© depuis la r√©ponse (de pr√©f√©rence)
if (response.tickets?.last !== undefined) {
  this.hasPendingPage = !response.tickets.last;
} else if (response.tickets?.number !== undefined && response.tickets?.totalPages !== undefined) {
  this.hasPendingPage = (response.tickets.number + 1) < response.tickets.totalPages;
} else {
  this.hasPendingPage = content.length === size; // fallback
}


// DashboardCardConfigFactory.loadTicketsByCard(...)
if (type !== FilterCardType.NONE) {
  params.cardType = type; // ‚Üê souvent ce qu‚Äôattend l‚ÄôAPI
  // params.cardType = FilterCardType[type]; // ‚Üê seulement si l‚ÄôAPI attend le nom string
}
