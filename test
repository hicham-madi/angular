export class SolicitingsTableComponent {
  // pagination
  private currentPage = 0;
  private readonly pageSize = 20;
  private isLoading = false;
  private hasMore = true;

  // tri courant
  private sortActive: string | null = null;          // ex: 'lastActivityTimestamp'
  private sortDirection: 'asc' | 'desc' | null = null;

  // (optionnel) mapping front -> back
  private readonly sortKeyMap: Record<string, string> = {
    id: 'ID',
    lastActivityTimestamp: 'LAST_ACTIVITY_TIMESTAMP',
    partLabel: 'PART_LABEL',
    domainLabel: 'DOMAIN_LABEL',
    objectLabel: 'OBJECT_LABEL',
    claimTypeLabel: 'CLAIM_TYPE_LABEL',
    slaLabel: 'SLA_LABEL',
    status: 'STATUS',
  };

  protected sortData(column: string): void {
    // cycle asc -> desc -> null
    if (this.sortActive !== column) {
      this.sortActive = column;
      this.sortDirection = 'asc';
    } else {
      this.sortDirection = this.sortDirection === 'asc' ? 'desc'
                       : this.sortDirection === 'desc' ? null : 'asc';
    }

    // reset listing & pagination
    this.tickets = [];
    this.currentPage = 0;
    this.hasMore = true;

    this.loadPage(0); // recharge la 1ère page avec le tri courant
  }

  public onCdkScroll(): void {
    if (this.isLoading || !this.hasMore) return;

    // ton calcul d’arrivée en bas reste inchangé…
    const viewport = this.cdkVirtualScroll!;
    const end = viewport.getRenderedRange().end;
    const total = viewport.getDataLength();

    if (end >= total - 1) {
      this.loadPage(this.currentPage + 1);
    }
  }

  private loadPage(page: number): void {
    this.isLoading = true;

    const sortKey =
      this.sortDirection && this.sortActive
        ? (this.sortKeyMap[this.sortActive] ?? this.sortActive) // si le back normalise, c’est ok
        : null;

    const request: any = {
      page,
      pageSize: this.pageSize,
      totalItems: this.tickets.length,
      context: this.context,
      status: '',
      ...(sortKey
        ? { sortKey, isAsc: this.sortDirection === 'asc' }
        : {}),
    };

    if (TicketContext.TERMINATED === this.context) {
      request.status = TicketStatus.CLOSED;
    }

    this.mbotService.getTicketListV2(request).subscribe({
      next: (response) => {
        const newTickets = response.tickets?.content ?? [];
        // append si page > 0
        this.tickets = page === 0 ? newTickets : [...this.tickets, ...newTickets];
        this.currentPage = page;
        this.hasMore = newTickets.length === this.pageSize; // stop si page incomplète
        this.isLoading = false;
        this.detectChanges();
      },
      error: () => {
        this.isLoading = false;
      },
    });
  }
}
