@Input() public hasPendingPage = false;
@Input() public loadingNextPage = false; // on le lie au parent pour blindage

private scrollLocked = false;
private lastLength = 0;

public ngOnChanges(): void {
  // RÃ©armement automatique dÃ¨s que la longueur change (nouvelle page appendÃ©e)
  const len = this.tickets?.length ?? 0;
  if (len !== this.lastLength) {
    this.lastLength = len;
    this.scrollLocked = false;
  }
}

public onCdkScroll(): void {
  if (!this.hasPendingPage) return;   // rien Ã  charger
  if (this.loadingNextPage) return;   // parent en cours de chargement
  if (this.scrollLocked) return;      // dÃ©jÃ  dÃ©clenchÃ© pour ce bas

  const end = this.viewport.getRenderedRange().end; // index exclusif du dernier item rendu
  const total = this.viewport.getDataLength();

  // DÃ©clenche exactement au bas (offset = 1 item ; mets 0 si tu veux le dernier pixel)
  const atBottom = end >= Math.max(0, total - 1);
  if (!atBottom) return;

  // ðŸ”’ verrouiller IMMÃ‰DIATEMENT pour Ã©viter les rafales
  this.scrollLocked = true;

  this.loadMore.emit({
    sortKey: this.sort?.active ?? null,
    isAsc: this.sort?.direction === 'asc' ? true
         : this.sort?.direction === 'desc' ? false
         : null,
  });
}

<metabot-solicitings-table
  ...
  [hasPendingPage]="hasPendingPage"
  [loadingNextPage]="isLoading"   <!-- important -->
  (loadMore)="onScroll(TicketContext.SOLICITATIONS)">
</metabot-solicitings-table>

if (page === 0) {
  this.tickets = content;
  this.loadedElements = content.length; // reset propre
} else {
  const existingIds = new Set(this.tickets.map((t) => t.id));
  const uniqueNewTickets = content.filter((t) => !existingIds.has(t.id));

  this.tickets = [...this.tickets, ...uniqueNewTickets];

  // âœ… Compter ce que TU AJOUTES rÃ©ellement Ã  l'Ã©cran, pas la taille brute de la rÃ©ponse
  this.loadedElements += uniqueNewTickets.length;
}

// --- Calcul fiable du "reste-t-il des pages ?" ---
// 1) Si l'API donne "last" :
if (response?.tickets?.last !== undefined) {
  this.hasPendingPage = !response.tickets.last;
}
// 2) Ou si elle donne (page courante, totalPages) :
else if (response?.tickets?.number !== undefined && response?.tickets?.totalPages !== undefined) {
  this.hasPendingPage = (response.tickets.number + 1) < response.tickets.totalPages;
}
// 3) Fallback : comparer Ã  la taille de page
else {
  const size = response?.tickets?.size ?? 20;
  this.hasPendingPage = (content?.length ?? 0) === size;
}

this.allPagesLoaded = !this.hasPendingPage;
this.listService.loadingResolver = false;


if (this.isLoading) return;
if (!this.hasPendingPage) return;

this.isLoading = true;
const complete = () => { this.isLoading = false; this.currentPage = nextPage; };
