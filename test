// ticket-list.resolver.ts
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
// ...

export class TicketListResolver implements Resolve<TicketListPrefetch> {
  // ...

  resolve(route: ActivatedRouteSnapshot, _state: RouterStateSnapshot) {
    const context = route.data['context'] as TicketContext;

    // ðŸ‘‡ typage littÃ©ral (pas "string")
    const initialTab: 'ongoing' | 'completed' =
      context === TicketContext.TERMINATED ? 'completed' : 'ongoing';

    // ...
    return forkJoin({
      tickets: this.mbot.getTicketListV2(params),
    }).pipe(
      map(({ tickets }) => ({
        context,
        initialTab,                                  // <- maintenant bien typÃ©
        config: { displayedColumns, columnConfig },  // types compatibles
        cardType,
        tickets,
      })),
      catchError(() =>
        of({
          context,
          initialTab,
          config: { displayedColumns, columnConfig },
          cardType,
          tickets: { content: [], totalElements: 0, size: 20, number: 0 },
        }),
      ),
    );
  }
}

ngOnInit(): void {
  const data = this.route.snapshot.data['prefetch'] as TicketListPrefetch;

  this.currentContext = data.context;
  this.currentTab = data.initialTab;

  if (!this.displayedColumns.length) this.displayedColumns = data.config.displayedColumns;
  if (!Object.keys(this.columnConfig || {}).length) this.columnConfig = data.config.columnConfig;

  this.activeCard = data.cardType ?? FilterCardType.NONE;
  if (this.activeCard && this.activeCard !== FilterCardType.NONE) {
    localStorage.setItem('lastSelectedCard', this.activeCard.toString());
  } else {
    localStorage.removeItem('lastSelectedCard');
  }

  // hydrate depuis le resolver
  this.handleTicketResponse(data.tickets, this.currentContext);

  // ðŸ‘‰ IMPORTANT : garder l'init (sockets, etc.)
  this.initialization(this.currentContext);

  // reste: sync URL -> carte + reload ciblÃ©
  this.route.queryParamMap.subscribe((params) => {
    const qp = (params.get('card') ?? '') as keyof typeof FilterCardType;
    const next =
      qp && FilterCardType[qp] !== undefined ? FilterCardType[qp] : FilterCardType.NONE;

    if (next !== this.activeCard) {
      this.activeCard = next;
      if (next !== FilterCardType.NONE) {
        localStorage.setItem('lastSelectedCard', next.toString());
      } else {
        localStorage.removeItem('lastSelectedCard');
      }
      this.loadTickets(this.activeCard, this.currentContext);
    }
  });
}
