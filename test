// inputs/outputs inchangés
@Input() resetSortToken: number | null = null;
@Output() sortChanged = new EventEmitter<{ sortKey: string | null; isAsc: boolean | null }>();

protected sort = {
  active: null as string | null,
  direction: null as 'asc' | 'desc' | null,
};

ngOnChanges(changes: SimpleChanges): void {
  // ✅ reset uniquement quand le token change (ET PAS au firstChange)
  if (changes['resetSortToken'] && !changes['resetSortToken'].firstChange) {
    this.sort.active = null;
    this.sort.direction = null;
  }
  this.cdkVirtualScroll?.scrollToIndex?.(0);
}

protected sortData(column: string): void {
  if (this.sort.active !== column) {
    this.sort.active = column;
    this.sort.direction = 'asc';
  } else {
    this.sort.direction =
      this.sort.direction === 'asc' ? 'desc' :
      this.sort.direction === 'desc' ? null  : 'asc';
  }

  // ✅ au 3e clic, on envoie null => le parent remettra le tri par défaut
  this.sortChanged.emit({
    sortKey: this.sort.direction ? this.sort.active : null,
    isAsc:  this.sort.direction ? this.sort.direction === 'asc' : null,
  });
}

protected getSortIcon(column: string): string {
  if (this.sort.active !== column || !this.sort.direction) return 'unfold_more';
  return this.sort.direction === 'asc' ? 'arrow_upward' : 'arrow_downward';
}


// Etat courant du tri côté page
private currentSort: { sortKey: string | null; isAsc: boolean | null } = {
  sortKey: null,
  isAsc: null,
};

public onSortChanged(e: { sortKey: string | null; isAsc: boolean | null }): void {
  this.currentSort = e;          // ✅ ne touche pas resetSortToken ici
  this.applyFilters();
}

protected applyFilters(): void {
  this.resetPagination();

  const hasValidSort = !!this.currentSort.sortKey && this.currentSort.isAsc !== null;

  const sortKey = hasValidSort ? this.currentSort.sortKey! : 'lastActivityTimestamp';
  const isAsc   = hasValidSort ? this.currentSort.isAsc!   : false;

  const opts = {
    sortKey,
    isAsc,
    searchTerm: this.searchTerm?.trim() ?? '',
    statusFilter: this.selectedStatus ?? '',
    agencyFilter: this.selectedAgency ?? '',
    collaboratorFilter: this.selectedCollaborator ?? '',
    campaignFilter: this.selectedCampaign ?? '',
  };

  const card = this.activeCard ?? FilterCardType.NONE;
  this.loadTicketsByCard(card, this.currentContext, 0, opts).subscribe({
    next: (response) => { this.handleTicketResponse(response); this.isLoading = false; },
    error: (err) => console.error('Erreur tri page 0 :', err),
  });
}



