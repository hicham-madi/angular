// ticket-list.resolver.ts
export interface TicketListPrefetch {
  context: TicketContext;
  initialTab: 'ongoing' | 'completed';  // <- littéral
  config: {
    displayedColumns: string[];
    columnConfig: Record<string, ColumnDefinition>;
  };
  cardType: FilterCardType;
  tickets: MbotListV2;
}


import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable, forkJoin, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class TicketListResolver implements Resolve<TicketListPrefetch> {

  constructor(
    private tableConfig: TableConfigFactory,
    private mbot: MbotServiceV2,
  ) {}

  resolve(route: ActivatedRouteSnapshot, _state: RouterStateSnapshot): Observable<TicketListPrefetch> {
    const context = route.data['context'] as TicketContext;

    // 1) onglet initial (typé littéral)
    const initialTab: 'ongoing' | 'completed' =
      context === TicketContext.TERMINATED ? 'completed' : 'ongoing';

    // 2) carte active (QP > localStorage > NONE) – bien typée
    const qp = (route.queryParamMap.get('card') ?? '') as keyof typeof FilterCardType;
    const stored = localStorage.getItem('lastSelectedCard') as keyof typeof FilterCardType | null;

    const cardType: FilterCardType =
      (qp && FilterCardType[qp] !== undefined) ? FilterCardType[qp] :
      (stored && FilterCardType[stored] !== undefined) ? FilterCardType[stored] :
      FilterCardType.NONE;

    // 3) config colonnes
    const cfg = context === TicketContext.TEAM
      ? this.tableConfig.getColumnsForTeamPage()
      : this.tableConfig.getBaseColumns();

    const displayedColumns: string[] = cfg.displayedColumns();
    const columnConfig: Record<string, ColumnDefinition> = cfg.columnConfig;

    // 4) premier fetch
    const params = { .../* ce que tu envoies déjà */, currentPages: 0, context };

    return forkJoin({
      tickets: this.mbot.getTicketListV2(params),
    }).pipe(
      map(({ tickets }) => ({
        context,
        initialTab,
        config: { displayedColumns, columnConfig },
        cardType,
        tickets,
      })),
      // fallback typé pareil
      catchError(() =>
        of({
          context,
          initialTab,
          config: { displayedColumns, columnConfig },
          cardType,
          tickets: { content: [], totalElements: 0, size: 20, number: 0 } as MbotListV2,
        }),
      ),
    );
  }
}

{
  path: 'ticket-list',
  loadComponent: () => import('@metabot/my-solicitings').then(m => m.TicketListPageComponent),
  resolve: { prefetch: TicketListResolver },
  data: { context: TicketContext.SOLICITATIONS },
}

ngOnInit(): void {
  const data = this.route.snapshot.data['prefetch'] as TicketListPrefetch;

  this.currentContext = data.context;
  this.currentTab = data.initialTab;

  if (!this.displayedColumns.length) this.displayedColumns = data.config.displayedColumns;
  if (!Object.keys(this.columnConfig || {}).length) this.columnConfig = data.config.columnConfig;

  this.activeCard = data.cardType ?? FilterCardType.NONE;
  if (this.activeCard && this.activeCard !== FilterCardType.NONE) {
    localStorage.setItem('lastSelectedCard', this.activeCard.toString());
  } else {
    localStorage.removeItem('lastSelectedCard');
  }

  this.handleTicketResponse(data.tickets, this.currentContext);   // hydrate
  this.initialization(this.currentContext);                       // sockets, etc.

  // sync URL -> carte
  this.route.queryParamMap.subscribe((params) => {
    const qp = (params.get('card') ?? '') as keyof typeof FilterCardType;
    const next = qp && FilterCardType[qp] !== undefined ? FilterCardType[qp] : FilterCardType.NONE;
    if (next !== this.activeCard) {
      this.activeCard = next;
      next !== FilterCardType.NONE
        ? localStorage.setItem('lastSelectedCard', next.toString())
        : localStorage.removeItem('lastSelectedCard');
      this.loadTickets(this.activeCard, this.currentContext);
    }
  });
}

