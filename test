// Inputs existants...
@Input() public hasPendingPage = false;
// (facultatif mais conseillé pour blindage)
@Input() public loadingNextPage = false;

private scrollLocked = false;
private lastLength = 0;

public ngOnChanges(): void {
  // Réarmement automatique dès que la longueur change (nouvelle page appendée)
  const len = this.tickets?.length ?? 0;
  if (len !== this.lastLength) {
    this.lastLength = len;
    this.scrollLocked = false;
  }
}

public onCdkScroll(): void {
  if (!this.hasPendingPage) return;      // plus rien à charger
  if (this.loadingNextPage) return;      // déjà en cours (si tu binds l’input)
  if (this.scrollLocked) return;         // on a déjà déclenché pour ce bas

  const end = this.viewport.getRenderedRange().end;   // index exclusif du dernier item rendu
  const total = this.viewport.getDataLength();

  // Déclenche quand on touche la fin de la data courante (offset = 1 item)
  const atBottom = end >= Math.max(0, total - 1);
  if (!atBottom) return;

  // Verrouille immédiatement pour empêcher les rafales
  this.scrollLocked = true;

  this.loadMore.emit({
    sortKey: this.sort?.active ?? null,
    isAsc: this.sort?.direction === 'asc' ? true
         : this.sort?.direction === 'desc' ? false
         : null,
  });
}

